1) Какой самый эффективный способ конкатенации строк?
    С помощью использования strings.Builder, ведь тогда не происходит копирования данных в новую область памяти(не создаётся новая строка)

2) Что такое интерфейсы, как они применяются в Go?
    Интерфейс это тип который определяет
    и описывает поведение структур реализующих его методы(исключение пустые интерфейсы).
    Интерфейсы позволяют абстрогировать поведение
    Интерфейсы уменьшают дублирование
    И их можно использовать как заглушки



3) Чем отличаются RWMutex от Mutex?
    RWMutex позволяет сразу нескольким горутинам параллельно читать объект.
    Но в тоже время Mutex проще по реализации и работает быстрее

4) Чем отличаются буферизированные и не буферизированные каналы?
    Буферезированные каналы не блокируют горутину до тех пор пока буфер не будет заполнен.
    Горутина будет считывать буфер, до тех пор пока он не станет пустым

5) Какой размер у структуры struct{}{}?
    0 байт

6) Есть ли в Go перегрузка методов или операторов?
    Нет

7) В какой последовательности будут выведены элементы map[int]int?
    Если выводить без определённой сортировки, то вывод будет в рандомном порядке, тк go не гарантирует порядок ключей карты

8) В чем разница make и new?
    make возвращает значение
    new  возвращает указатель

9) Сколько существует способов задать переменную типа slice или map?
    4 способа
    примеры map:
    var m map[string]int                                             

    m1 := make(map[string]float64)    
                                   
    m2 := make(map[string]float64, 100)  
                                   
    m3 := map[string]float64{           
        "e":  2.71828,
        "pi": 3.1416,
    }
10) Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

output:
1
1 
тк. в функции меняется указатель, а не значение на которое этот указатель указывает *p = a изменило бы

11) Что выведет данная программа и почему?


func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

output:
выведет числа от 0 до 4 в случайном порядке и упадет в дедлок
что бы избежать нужно передавать указатель на WaitGroup 


12) Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

output:
0
в блоке if объявляется новая переменная n которая существует только в этом блоке

13) Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

output:
100 2 3 4 5 
append возвращает новый слайс а в функцию он передается по значению
что бы все работало функция должна выглядеть так:
func someAction(v *[]int8, b int8) {
  (*v)[0] = 100
  *v = append(*v, b)
}

14) Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

output:
[b b a][a a]
В фукции 0 и 1 элемент изменятся в другом слайсе тк до этого был append, если его
поставить после изменения то принт после функции выведе [b b]